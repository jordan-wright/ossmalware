package main

import (
	"encoding/xml"
	"fmt"
	"net/http"
	"time"
)

const (
	delta   = 5 * time.Minute
	baseURL = "https://pypi.org/rss/updates.xml"
)

type Response struct {
	Packages []*Package `xml:"channel>item"`
}

type Package struct {
	// ModifiedDate rfc1123Time `xml:"pubDate"`
	Link    string `xml:"link"`
	Name    string `xml:"-"`
	Version string `xml:"-"`
}

func (p *Package) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var pkg Package
	fmt.Printf("%s", start)
	err := d.DecodeElement(&pkg, &start)
	if err != nil {
		return err
	}
	*p = pkg
	return nil
}

type rfc1123Time struct {
	time.Time
}

func (t *rfc1123Time) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var marshaledTime string
	err := d.DecodeElement(&marshaledTime, &start)
	if err != nil {
		return err
	}
	decodedTime, err := time.Parse(time.RFC1123, marshaledTime)
	if err != nil {
		return err
	}
	*t = rfc1123Time{decodedTime}
	return nil
}

func fetchPackages() ([]*Package, error) {
	client := &http.Client{
		Timeout: 10 * time.Second,
	}
	resp, err := client.Get(baseURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	rssResponse := &Response{}
	err = xml.NewDecoder(resp.Body).Decode(rssResponse)
	if err != nil {
		return nil, err
	}
	return rssResponse.Packages, nil
}

func poll() (string, error) {
	packages, err := fetchPackages()
	if err != nil {
		return "", err
	}
	// cutoff := time.Now().UTC().Add(-delta)
	for _, pkg := range packages {
		// if pkg.ModifiedDate.Before(cutoff) {
		// 	continue
		// }
		fmt.Printf("%#v", pkg)
	}
	return fmt.Sprintf("processing %d packages", len(packages)), nil
}

func main() {
	result, err := poll()
	if err != nil {
		panic(err)
	}
	fmt.Println(result)
	// lambda.Start(poll)
}
