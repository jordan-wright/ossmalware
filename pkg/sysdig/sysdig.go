package sysdig

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/exec"
	"strconv"
	"strings"

	"github.com/jordan-wright/ossmalware/pkg/library"
)

const outputFormat = "*%evt.num %evt.outputtime %container.name %proc.name (%thread.tid:%thread.vtid) %evt.dir %evt.type %evt.info %evt.arg.flags %fd.name %fd.cip %fd.sip %fd.sport %proc.exeline"

type Process struct {
	cmd *exec.Cmd
}

func (sysdig *Process) Stop() error {
	err := sysdig.cmd.Process.Signal(os.Interrupt)
	if err != nil {
		return fmt.Errorf("error sending interrupt to sysdig: %w", err)
	}
	_, err = sysdig.cmd.Process.Wait()
	return err
}

func generateSysdigArgs(pkgName, outputPath string, filters ...string) []string {
	args := []string{"-p", outputFormat, "-w", outputPath}
	fs := []string{fmt.Sprintf("container.name=%s", pkgName)}
	for _, filter := range filters {
		fs = append(fs, filter)
	}
	args = append(args, strings.Join(fs, " and "))
	return args
}

func Run(ctx context.Context, pkgName, outputPath string, filters ...string) (*Process, error) {
	args := generateSysdigArgs(pkgName, outputPath, filters...)
	sysdig := exec.Command("sysdig", args...)
	err := sysdig.Start()
	if err != nil {
		return nil, err
	}
	return &Process{
		cmd: sysdig,
	}, nil
}

var metadataFilters = []string{
	"((evt.type=connect) and evt.dir=<)",
	"((evt.type=execve or evt.type=execveat) and evt.dir=<)",
	"((evt.type=open or evt.type=openat) and evt.dir=<)",
}

func createMetadataFilter(ignoreFilters ...string) string {
	filter := strings.Join(metadataFilters, " or ")
	if len(ignoreFilters) > 0 {
		filter = fmt.Sprintf("(%s) and %s", filter, strings.Join(ignoreFilters, " and "))
	}
	return filter
}

// ParseMetadata reads the captured scap file to update the metadata based on the results
func ParseMetadata(filepath string, ignoreFilters ...string) (*library.Behavior, error) {
	filter := createMetadataFilter(ignoreFilters...)
	cmd := exec.Command("sysdig", "-r", filepath, "-j", "-p", outputFormat, filter)
	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return nil, fmt.Errorf("error generating stdout pipe: %w", err)
	}
	err = cmd.Start()
	if err != nil {
		return nil, fmt.Errorf("error running sysdig: %w", err)
	}

	behavior := &library.Behavior{}
	scanner := bufio.NewScanner(stdout)
	cache := map[string]map[string]bool{
		"commands":    {},
		"files":       {},
		"connections": {},
	}
	for scanner.Scan() {
		syscall := make(map[string]interface{})
		entry := scanner.Bytes()
		err := json.Unmarshal(entry, &syscall)
		if err != nil {
			log.Printf("error unmarshaling entry: %s: %v", entry, err)
			continue
		}
		switch syscall["evt.type"] {
		case "execve", "execveat":
			command := syscall["proc.exeline"].(string)
			if _, ok := cache["commands"][command]; ok {
				break
			}
			behavior.Commands = append(behavior.Commands, command)
			cache["commands"][command] = true
		case "open":
			if syscall["fd.name"] == nil {
				break
			}
			filename := syscall["fd.name"].(string)
			if filename == "" {
				break
			}
			if _, ok := cache["files"][filename]; ok {
				break
			}
			flag := ""
			if syscall["evt.arg.flags"] != nil {
				flag = syscall["evt.arg.flags"].(string)
			}
			behavior.FileOperations = append(behavior.FileOperations, library.FileOperation{
				Filename: filename,
				Flag:     flag,
			})
			cache["files"][filename] = true
		case "connect":
			if syscall["fd.sip"] == nil || syscall["fd.sport"] == nil {
				break
			}
			sip := syscall["fd.sip"].(string)
			port := strconv.Itoa(int(syscall["fd.sport"].(float64)))
			cacheID := fmt.Sprintf("%s:%s", sip, port)
			if _, ok := cache["connections"][cacheID]; ok {
				break
			}
			behavior.OutboundConnections = append(behavior.OutboundConnections, library.Connection{
				IPAddress: sip,
				Port:      port,
			})
			cache["connections"][cacheID] = true
		}
	}
	cmd.Wait()
	return behavior, nil
}
