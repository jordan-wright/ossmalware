package producer

import (
	"encoding/json"
	"log"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/sqs"
	"github.com/jordan-wright/ossmalware/pkg/library"
)

type Producer interface {
	Add(pkg library.Package) error
	Flush() error
}

const SQSMaxBatchSize = 10

type SQSProducer struct {
	client   *sqs.SQS
	queueURL *string
	batch    []*sqs.SendMessageBatchRequestEntry
}

func NewSQSProducer(sess *session.Session, queue string) (*SQSProducer, error) {
	client := sqs.New(sess)
	result, err := client.GetQueueUrl(&sqs.GetQueueUrlInput{
		QueueName: &queue,
	})
	if err != nil {
		return nil, err
	}
	consumer := &SQSProducer{
		client:   client,
		queueURL: result.QueueUrl,
	}
	return consumer, nil
}

func (p *SQSProducer) Add(pkg library.Package) error {
	body, err := json.Marshal(pkg)
	if err != nil {
		return err
	}
	p.batch = append(p.batch, &sqs.SendMessageBatchRequestEntry{
		Id:          aws.String(pkg.ID()),
		MessageBody: aws.String(string(body)),
	})
	if len(p.batch) > SQSMaxBatchSize {
		err = p.Flush()
		if err != nil {
			return err
		}
	}
	return nil
}

func (p *SQSProducer) Flush() error {
	response, err := p.client.SendMessageBatch(&sqs.SendMessageBatchInput{
		Entries:  p.batch,
		QueueUrl: p.queueURL,
	})
	if err != nil {
		return err
	}
	for _, failed := range response.Failed {
		log.Printf("error sending %s to queue: %s", aws.StringValue(failed.Id), aws.StringValue(failed.Message))
	}
	return nil
}
