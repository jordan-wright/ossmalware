package processor

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"

	"github.com/docker/docker/api/types"
	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/client"
	"github.com/jordan-wright/ossmalware/pkg/library"
)

const TypeGem = "gem"
const GemSimpleURL = "https://rubygems.org/gems/"
const BaseImageGem = "ruby:3.2-rc-alpine"

var IgnoredHostsGem = []string{"rubygems.org"}

var SysdigFiltersGem = []string{
	"not (fd.sip.name=rubygems.org or fd.cip.name=rubygems.org)",
}

// SysdigFiltersIgnoreGem is the list of sysdig events that might appear
// suspicious, but are known parts of Python package installation.
//
// No, these aren't perfect, but the goal is catching the low-hanging fruit and
// we can iterate as we go.
var SysdigFiltersIgnoreGem = []string{
	"not (proc.exeline='uname -p')",
	"not (proc.exeline='uname -rs')",
// 	"not (proc.exeline contains '/usr/local/bin/python -c import sys, setuptools, tokenize; sys.argv[0]')",
// 	"not (proc.exeline contains '/usr/local/bin/python -u -c import sys, setuptools, tokenize; sys.argv[0]')",
// 	"not (fd.name contains '/usr/local/lib/python3.8/')", // Might need to make this more granular
// 	"not (fd.name contains '/lib/' and evt.arg.flags contains O_RDONLY)",
}

type GemProcessor struct {
	BaseProcessor
}

func NewGemProcessor() *GemProcessor {
	return &GemProcessor{
		BaseProcessor: BaseProcessor{
			Output: &library.Output{},
		},
	}
}

// fetchMetadata is a temporary struct to only parse out the Python package
// version in cases where we don't already have it.
type fetchMetadata struct {
	Info infoMetadata `json:"info"`
}

type infoMetadata struct {
	Version string `json:"version"`
}

func (p *GemProcessor) fetchMetadata(pkg *library.Package, outputDir string) (string, error) {
	url := fmt.Sprintf("https://rubygems.org/gems/%s", pkg.Name)
	if pkg.Version != "" {
		url += fmt.Sprintf("/%s", pkg.Version)
	}
	url += "/json"
	log.Printf("fetching metadata for %s", url)

	response, err := http.Get(url)
	if err != nil {
		return "", err
	}
	defer response.Body.Close()

	metadata, err := ioutil.ReadAll(response.Body)
	if err != nil {
		return "", fmt.Errorf("error reading response body: %w", err)
	}
	var parsedMetadata fetchMetadata
	err = json.Unmarshal(metadata, &parsedMetadata)
	if err != nil {
		return "", fmt.Errorf("error parsing metadata json: %w", err)
	}
	pkg.Version = parsedMetadata.Info.Version
	metadataFilename := filepath.Join(outputDir, fmt.Sprintf("%s_metadata.json", pkg.ID()))
	return metadataFilename, ioutil.WriteFile(metadataFilename, metadata, 0644)
}

func (p *GemProcessor) Process(ctx context.Context, cli *client.Client, pkg library.Package) (*library.Output, error) {
	wd, _ := os.Getwd()

	metadataPath, err := p.fetchMetadata(&pkg, wd)
	if err != nil {
		return nil, err
	}
	p.PackageID = pkg.ID()
	p.Output.Files = append(p.Output.Files, metadataPath)

	err = p.StartMonitoring(ctx, cli)
	if err != nil {
		return nil, err
	}

	log.Printf("Creating container: %s", p.PackageID)
	resp, err := cli.ContainerCreate(ctx, &container.Config{
		Image: BaseImageGem,
		Tty:   false,
		Cmd:   []string{"gem", "install", fmt.Sprintf("%s", pkg.Name), "-v", fmt.Sprintf("%s", pkg.Version)},
	}, &container.HostConfig{NetworkMode: p.BaseProcessor.tcpdumpContainer.NetworkMode()}, nil, pkg.ID())

	if err != nil {
		p.StopMonitoring()
		return nil, err
	}

	log.Printf("Starting container: %s", p.PackageID)
	if err := cli.ContainerStart(ctx, resp.ID, types.ContainerStartOptions{}); err != nil {
		p.StopMonitoring()
		return nil, err
	}

	statusCh, errCh := cli.ContainerWait(ctx, resp.ID, container.WaitConditionNotRunning)
	select {
	case err := <-errCh:
		if err != nil {
			p.StopMonitoring()
			return nil, err
		}
	case <-statusCh:
	}

	log.Printf("Removing container: %s", p.PackageID)
	err = cli.ContainerRemove(ctx, resp.ID, types.ContainerRemoveOptions{})
	if err != nil {
		p.StopMonitoring()
		return nil, err
	}

	err = p.StopMonitoring()
	if err != nil {
		return nil, err
	}

	p.Output.Package = pkg

	sysdigIgnoredFilters := []string{}
	for _, filter := range SysdigFiltersIgnoreGem {
		sysdigIgnoredFilters = append(sysdigIgnoredFilters, filter)
	}
	// To keep the logs clean, don't log this specific command
	sysdigIgnoredFilters = append(sysdigIgnoredFilters, fmt.Sprintf("not ((evt.type=execve or evt.type=execveat) and proc.exeline='/usr/local/bin/gem install %s -v %s')", pkg.Name, pkg.Version))
	err = p.parseBehavior(sysdigIgnoredFilters, IgnoredHostsGem...)
	if err != nil {
		return nil, fmt.Errorf("error parsing output: %w", err)
	}

	return p.Output, nil
}
